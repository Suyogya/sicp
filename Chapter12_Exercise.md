## 1.9
Each of the following two procedures defines a method for adding two positive integers in terms of the procedures inc, which increments its argument by 1, and dec, which decrements its argument by 1.

```lisp
(define (+ a b)
    (if (= a 0)
        b
        (inc (+ (dec a) b))
    )
)

(define (+ a b)
    (if (= a 0)
        b
        (+ (dec a) (inc b))
    )
)
```

Using the substitution model, illustrate the process generated by each procedure in evaluating (+ 4 5). Are these processes iterative or recursive?

### Answer
Using the first definition
```lisp
(+ 4 5)
;(inc (+ (dec 4) 5)))
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
```

This is recursive process

Uing the second definition
```lisp
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
```
This is iterative process

## 1.10
The following procedure computes a mathematical function called Akermann's function

```lisp
(define (A x y)
    (cond ((= y 0) 0)
          ((= x 0) (* 2 y))
          ((= y 1) 2)
          (else (A (- x 1)
                (A x (- y 1)))
          )
    )
)
```

What are the values of the following expressions?
```lisp
(A 1 10)
(A 2 4)
(A 3 3)
```

Consider the following procedures, where A is the procedure defined above:

```lisp
(define (f n) (A 0 n))

(define (g n) (A 1 n))

(define (h n) (A 2 n))

(define (k n) (* 5 n n))
```
Give concise mathematical definitions for the functions computed by the procedures f, g, and h for positive integer values of n. For example, (k n) computes 5n2.

### Answer
```lisp
(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
(A 0 (A 0 (A 0 A(1 7))))
(A 0 (A 0 (A 0 (A 0 (A 1 6)))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))
(A 0 (A 0 (A 0 (A 0 (A 0 32)))))
(A 0 (A 0 (A 0 (A 0 64))))
(A 0 (A 0 (A 0 128)))
(A 0 (A 0 256))
(A 0 512)
1024
```
```lisp
(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (A 0 2)))
(A 1 (A 1 4))
(A 1 (A 0 (A 1 3)))
(A 1 (A 0 (A 0 (A 1 2))))
(A 1 (A 0 (A 0 (A 0 (A 1 1)))))
(A 1 (A 0 (A 0 (A 0 2))))
(A 1 (A 0 (A 0 4)))
(A 1 (A 0 8))
(A 1 16)
(A 1 16)
(A 0 (A 1 15))
(A 0 (A 0 (A 1 14)))
...
...
...
65536
```

```lisp
(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 (A 1 (A 2 1)))
(A 2 (A 1 2))
(A 2 (A 0 (A 1 1)))
(A 2 (A 0 2))
(A 2 4)
...
...
...
65536
```

Concise mathematical formula:

```lisp
(f n)
(A 0 n)
(* 2 n)
```
f(n) = 2 * n

```lisp
(g n)
(A 1 n)
(A 0 (A 1 (- n 1)))
(A 0 (A 0 (A 1 (- n 2))))
...
...
(A 0 (A 0 (A 0 (A 0 (....... (A 1 1))))))
...
...
(* 2 (* 2 (* 2 (* 2....... (* 2 2)))))
```
g(n) = 2<sup>n</sup>

```lisp
(h n)
(h 2 n)
(h 1 (h 2 (- n 1)))
(h 1 (h 1 (h 1 (- n 2))))
(h 1 (h 1 (h 1 (h 1 ...... (h 2 1)))))
(^ 2 (^ 2 (^ 2 (^2 (..... (^ 2 2))))))
```

h(n) = 2^2^2^... (n -1 times)

## 1.11
 function f is defined by the rule that f(n) = n if n<3 and f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3) if n &ge; 3. Write a procedure that computes f by means of a recursive process. Write a procedure that computes f by means of an iterative process.

### Answer
Recursive:

```lisp
(define (f11-recur n)
    (if (< n 3)
        n
        (+ (f11-recur (- n 1)) 
           (* 2 (f11-recur (- n 2))) 
           (* 3 (f11-recur (- n 3)))
        )
    )
)
 ```

Iterative:
```lisp
(define (f11-iter n)
    (define (iter a b c count)
        (if (> count n)
            a
            (iter b c (+ (* 3 a) (* 2 b) c) (1+ count))
        )
    )
    (iter 0 1 2 1)
)
 ```

## 1.12

The following pattern of numbers is called Pascal's triangle.

```
             1
            1 1
           1 2 1
          1 3 3 1
         1 4 6 4 1
            ...
```

The numbers at the edge of the triangle are all 1, and each number inside the triangle is the sum of the two numbers above it. Write a procedure that computes elements of Pascal's triangle by means of a recursive process.

### Answer
```lisp
(define (pascal r c)
   (cond ((or (= c 0) (= r c)) 1)
         ((or (< c 0) (< r c)) 0)
          (else (+ (pascal (- r 1) (- c 1))
                   (pascal (- r 1) c)
                )
          )
    )
)
```
### 1.13
Prove that Fib(n) is the closest integer to &#x3a6;<sup>n</sup>/5<sup>&#xbd;</sup>, where &#x3a6; = (1 + 5<sup>&#xbd;</sup>)/2. Hint: Let &#x3a8; = (1 - 5<sup>&#xbd;</sup>)/2. Use induction and the definition of the Fibonacci numbers to prove that Fib(n) = (&#x3a6;<sup>n</sup> - &#x3a8;<sup>n</sup>)/5<sup>&#xbd;</sup>.
For the first part, define:
```lisp
(define phi (/ (+ 1 (sqrt 5)) 2))

(define (phi-fib n)
    (/ (^ phi n) (sqrt 5))
)
 ```

```lisp
=> (phi-fib 1)
.7236067059356593
;~= 1

=> (phi-fib 2)
1.1708205768786706
; ~= 1

=> (phi-fib 3)
1.8944280256081427
; ~= 2

=> (phi-fib 4)
3.0652498043527894
;~= 3

=> (phi-fib 5)
4.959679774621483
;~= 5
```

To prove using induction

&#x3a6;<sup>2</sup> = &#x3a6; + 1<br>
&#x3a6; = (1 + &#x3a6;)/&#x3a6;<br>
&#x3a6; = 1 + 1/&#x3a6;

&#x3a8;<sup>2</sup> = &#x3a8; + 1<br>
&#x3a8; = (1 + &#x3a8;)/&#x3a8;<br>
&#x3a8; = 1 + 1/&#x3a8;

Fib (0) = 0<br>
Fib (1) = 1<br>
Fib (2) = 1<br>

Using formula (F(n) = (&#x3a6;<sup>n</sup> - &#x3a8;<sup>n</sup>)/5<sup>&#xbd;</sup>)<br>

Fib (0) = (&#x3a6;<sup>0</sup> - &#x3a8;<sup>0</sup>)/5<sup>&#xbd;</sup><br>
Fib (0) = (1 - 1)/5<sup>&#xbd;</sup><br>
Fib (0) = 0/5<sup>&#xbd;</sup><br>
Fib (0) = 0


Fib (1) = (&#x3a6;<sup>1</sup> - &#x3a8;<sup>1</sup>)/5<sup>&#xbd;</sup><br>
Fib (1) = (&#x3a6; - &#x3a8;)/5<sup>&#xbd;</sup><br>
Fib (1) = (((1 + 5<sup>&#xbd;</sup>)/2) - (1 - 5<sup>&#xbd;</sup>)/2)/5<sup>&#xbd;</sup><br>
Fib (1) = (2.5<sup>&#xbd;</sup>)/2)/5<sup>&#xbd;</sup><br>
Fib (1) = 1

Fib (2) = (&#x3a6;<sup>2</sup> - &#x3a8;<sup>2</sup>)/5<sup>&#xbd;</sup><br>
Fib (2) = ((1 + 5<sup>&#xbd;</sup>)/2)<sup>2</sup> - ((1 - 5<sup>&#xbd;</sup>)/2)<sup>2</sup>)/5<sup>&#xbd;</sup><br>
Fib (2) = ((1 + 5 + 2.5<sup>&#xbd;</sup>)/4 - (1 + 5 - 2.5<sup>&#xbd;</sup>)/4)/5<sup>&#xbd;</sup><br>
Fib (2) = (4.5<sup>&#xbd;</sup>/4)/5<sup>&#xbd;</sup><br>
Fib (2) = 1

Let's say,

for n,<br>
Fib (n) = (&#x3a6;<sup>n</sup> - &#x3a8;<sup>n</sup>)/5<sup>&#xbd;</sup>

and n - 1<br>
(&#x3a6;<sup>n - 1</sup> - &#x3a8;<sup>n - 1</sup>)/5<sup>&#xbd;</sup>

Then for n + 1,<br>
F (n + 1) = F(n) + F(n - 1)<br>
= (&#x3a6;<sup>n</sup> - &#x3a8;<sup>n</sup>)/5<sup>&#xbd;</sup> + (&#x3a6;<sup>n - 1</sup> - &#x3a8;<sup>n - 1</sup>)/5<sup>&#xbd;</sup><br>
= (&#x3a6;<sup>n</sup> + &#x3a6;<sup>n - 1</sup> -(&#x3a8;<sup>n</sup> + &#x3a8;<sup>n - 1</sup>))/5<sup>&#xbd;</sup><br>
= (&#x3a6;<sup>n + 1</sup>(&#x3a6;<sup>-1</sup> + &#x3a6;<sup>-2</sup>) - &#x3a8;<sup>n + 1</sup>(&#x3a8;<sup>-1</sup> + &#x3a8;<sup>-2</sup>))/5<sup>&#xbd;</sup><br>
= (&#x3a6;<sup>n + 1</sup>.&#x3a6;<sup>-1</sup>(1 + &#x3a6;<sup>-1</sup>) - &#x3a8;<sup>n + 1</sup>.&#x3a8;<sup>-1</sup>(1 + &#x3a8;<sup>-1</sup>))/5<sup>&#xbd;</sup><br>
= (&#x3a6;<sup>n + 1</sup>.(1/&#x3a6;).(1 + 1/&#x3a6;) - &#x3a8;<sup>n + 1</sup>.(1/&#x3a8;).(1 + 1/&#x3a8;))/5<sup>&#xbd;</sup><br>
= (&#x3a6;<sup>n + 1</sup>.(1/&#x3a6;).&#x3a6; - &#x3a8;<sup>n + 1</sup>.(1/&#x3a8;).&#x3a8;)/5<sup>&#xbd;</sup><br>
= (&#x3a6;<sup>n + 1</sup> - &#x3a8;<sup>n + 1</sup>)/5<sup>&#xbd;</sup>
